#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <utility/imumaths.h>
#include <math.h>
#include <PWMServo.h>

#include <PID_v2.h>


PWMServo rollServo; 
PWMServo pitchServo;
PWMServo yawServo;

float q0;
float q1;
float q2;
float q3;

int temp = 0;

// Specify the links and initial tuning parameters
double Kp = 2, Ki = 5, Kd = .00001;
PID_v2 rollPID(Kp, Ki, Kd, PID::Direct);
PID_v2 pitchPID(Kp, Ki, Kd, PID::Direct);
PID_v2 yawPID(Kp, Ki, Kd, PID::Direct);



#define BNO055_SAMPLERATE_DELAY_MS (10)

Adafruit_BNO055 myIMU = Adafruit_BNO055();

double rollActual;
double pitchActual;
double yawActual;
double rollServoVal;
double rollTarget;
double pitchServoVal;
double pitchTarget;
double yawTarget;
double yawServoVal;

void setup() {

  Serial.begin(115200);
  myIMU.begin();
  delay(1000);
  temp = myIMU.getTemp();
  myIMU.setExtCrystalUse(true);
  
  rollServo.attach(0, 1000, 2000);
  pitchServo.attach(1, 1000, 2000);
  yawServo.attach(2, 1000, 2000);

  //rollPID.SetOutputLimits(0, 180);

  rollPID.Start(rollActual,    // input/IMU Data
                rollServoVal,     // Servo Command
                rollTarget);   // setpoint
  pitchPID.Start(pitchActual,   // input/IMU Data
                pitchServoVal,    // Servo Command
                pitchTarget);  // setpoint
  yawPID.Start(yawActual,      // input/IMU Data
               yawServoVal,       // Servo Command
               yawTarget);     // setpoint
}

void loop() {

  uint8_t system, gyro, accel, mg = 0;
  myIMU.getCalibration(&system, &gyro, &accel, &mg);

  imu::Quaternion quat = myIMU.getQuat();

  rollActual = atan2(2 * (quat.w() * quat.x() + quat.y() * quat.z()), 1 - 2 * (quat.x() * quat.x() + quat.y() * quat.y()));
  pitchActual = asin(2 * quat.w() * quat.y() - quat.x() * quat.z());
  yawActual = atan2(2 * (quat.w() * quat.z() + quat.x() * quat.y()), 1 - 2 * (quat.y() * quat.y() + quat.z() * quat.z()));

  rollActual = rollActual / (2 * 3.141592654) * 360;
  pitchActual = pitchActual / (2 * 3.141592654) * 360;
  yawActual = yawActual / (2 * 3.141592654) * 360;

rollPID.SetOutputLimits(-180, 180);
pitchPID.SetOutputLimits(-180, 180);
yawPID.SetOutputLimits(-180, 180);

  double rollServoVal = rollPID.Run(rollActual);
  double pitchServoVal = pitchPID.Run(pitchActual);
  double yawServoVal = yawPID.Run(yawActual);

  //rollServo.write(rollServoVal);
  rollServo.write(rollServoVal);
  delay(20);
  pitchServo.write(pitchServoVal);
  delay(20);
  yawServo.write(yawServoVal);
  delay(20);

  Serial.print(rollTarget);
  Serial.print(",");
  Serial.print(rollActual);
  Serial.print(",");
  Serial.print(pitchTarget);
  Serial.print(",");
  Serial.print(pitchActual);
  Serial.print(",");
  Serial.print(yawTarget);
  Serial.print(",");
  Serial.print(yawActual);
  Serial.print(",");
  Serial.print(accel);
  Serial.print(",");
  Serial.print(gyro);
  Serial.print(",");
  Serial.print(mg);
  Serial.print(",");
  Serial.print(system);
  Serial.print(",");
  Serial.print(rollServoVal);
  Serial.print(",");
  Serial.print(pitchServoVal);
  Serial.print(",");
  Serial.println(yawServoVal);

  delay(BNO055_SAMPLERATE_DELAY_MS);
}
